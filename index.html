<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>YouTube 2x (no autoplay, cover)</title>
    <style>
      html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        background: transparent;
        overflow: hidden;
      }

      /* Full-bleed stage that clips overflow (cropping) */
      #stage {
        position: fixed;
        inset: 0;
        overflow: hidden;
        background: transparent;
      }

      /* YT iframe will be positioned/sized by JS to "cover" */
      #player iframe {
        position: absolute;
        border: 0;
        display: block;
      }
    </style>
  </head>

  <body>
    <div id="stage">
      <div id="player"></div>
    </div>

    <script>
      const VIDEO_ID = "pYLxtEYevp8";
      const TARGET_RATE = 2;

      // Optional: tweak crop without redeploying, e.g. ?zoom=1.25
      const params = new URLSearchParams(location.search);
      const ZOOM = Number(params.get("zoom")) || 1.18; // increase if borders still show

      // YouTube videos are effectively 16:9 for sizing purposes
      const VIDEO_RATIO = 16 / 9;

      // Load the YouTube IFrame Player API
      (function loadYT() {
        const tag = document.createElement("script");
        tag.src = "https://www.youtube.com/iframe_api";
        document.head.appendChild(tag);
      })();

      let player;
      let lastState = -1;
      let iframeEl = null;

      function sizeIframeToCover() {
        if (!iframeEl) return;

        const stage = document.getElementById("stage");
        const w = stage.clientWidth;
        const h = stage.clientHeight;
        const containerRatio = w / h;

        let iw, ih;

        // "Cover" logic: make iframe big enough to cover stage in both dimensions
        if (containerRatio > VIDEO_RATIO) {
          iw = w;
          ih = w / VIDEO_RATIO;
        } else {
          ih = h;
          iw = h * VIDEO_RATIO;
        }

        // Overscan zoom to crop away baked-in borders
        iw *= ZOOM;
        ih *= ZOOM;

        iframeEl.style.width = `${iw}px`;
        iframeEl.style.height = `${ih}px`;
        iframeEl.style.left = `${(w - iw) / 2}px`;
        iframeEl.style.top = `${(h - ih) / 2}px`;
      }

      function forceRate() {
        try {
          const rates = player.getAvailablePlaybackRates?.() || [];
          if (rates.length && !rates.includes(TARGET_RATE)) {
            player.setPlaybackRate(rates[rates.length - 1]); // fallback: max available
            return;
          }
          player.setPlaybackRate(TARGET_RATE);
        } catch (_) {}
      }

      // Called automatically by the YT API once it's ready
      function onYouTubeIframeAPIReady() {
        player = new YT.Player("player", {
          videoId: VIDEO_ID,
          playerVars: {
            autoplay: 0,      // no autoplay
            controls: 1,
            rel: 0,
            playsinline: 1
          },
          events: {
            onReady: () => {
              // Grab the generated iframe and apply cover sizing
              iframeEl = document.querySelector("#player iframe");
              sizeIframeToCover();
              window.addEventListener("resize", sizeIframeToCover);

              // Ensure sound is allowed (autoplay is off anyway)
              try { player.unMute(); } catch (_) {}
            },
            onStateChange: (event) => {
              const state = event.data;

              // When user presses play -> force 2x (and again shortly after)
              if (state === YT.PlayerState.PLAYING && lastState !== YT.PlayerState.PLAYING) {
                forceRate();
                setTimeout(forceRate, 250);
                setTimeout(forceRate, 1000);
              }

              lastState = state;
            }
          }
        });
      }
    </script>
  </body>
</html>
